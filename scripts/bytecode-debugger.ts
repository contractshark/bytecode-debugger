#!/usr/bin/env -S npx ts-node

import Memory from "@ethereumjs/vm/dist/evm/memory";
import { BN } from "ethereumjs-util";
import Stack from "@ethereumjs/vm/dist/evm/stack";
import { Opcode, OpcodeList } from "@ethereumjs/vm/dist/evm/opcodes";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";

import Table from "cli-table";
import chalk, { Chalk } from "chalk";
import _ from "lodash";
import { StorageDump } from "@ethereumjs/vm/dist/state/interface";
import { ExecutionManager, ExecutionInfo } from "../src/execution-manager";
import { toPrettyHex, toPrettyByte, incrementCounter } from "../src/utils";
import { prompt } from "enquirer";
import fs from "fs";
import { utils } from "ethers";
import jsonfile from "jsonfile";

debugBytecode();

async function debugBytecode() {
  const commandArguments = await yargs(hideBin(process.argv))
    .option("b", {
      description: `A path to a file containing the bytecode to debug.
    This is should be the ${chalk.bold("runtime")} bytecode.
    This can be created by passing the '--bin-runtime' flag into solc.`,
      alias: "bytecodeFile",
      demandOption: true,
      type: "string",
    })
    .option("a", {
      alias: "abi",
      description: `A path to the abi file generated by solc.
    This can be created by passing the '--bin-runtime' flag into solc.`,

      type: "string",
      default: "0",
    })
    .option("v", {
      alias: "callvalue",
      type: "string",
      description: `The call value to use for debugging`,
      default: "0",
    }).argv;

  const abiFile = await jsonfile.readFile(commandArguments.a);
  const abi = new utils.Interface(abiFile);
  const choices = Object.keys(abi.functions);

  const { functionToCall } = (await prompt({
    type: "select",
    name: "functionToCall",
    choices,
    message: "Which function do you want to call?'",
  })) as { functionToCall: string };

  let inputValues = [];
  for (const input of abi.functions[functionToCall].inputs) {
    if (input.baseType === "array" || input.baseType === "tuple") {
      throw new Error(`Sorry, currently we don't support complex parameters`);
    }

    const { inputValue } = (await prompt({
      type: "numeral",
      name: "inputValue",
      message: `Enter a value for ${functionToCall}'s argument ${input.name}`,
    })) as { inputValue: number };
    inputValues.push(inputValue);
  }
  const callData = abi.encodeFunctionData(
    abi.functions[functionToCall],
    inputValues
  );

  const { callValue } = (await prompt({
    type: "numeral",
    name: "callValue",
    message: `Enter the amount for the call value. This is the amount of wei that would be sent with the transaction.`,
  })) as { callValue: number };

  const code = Buffer.from(
    await fs.promises.readFile(commandArguments.b, "utf8"),
    "hex"
  );
  await runCode(
    code,
    Buffer.from(callData.slice(2), "hex"),
    new BN(callValue),
    abi.functions[functionToCall]
  );
}

async function runCode(
  code: Buffer,
  callData: Buffer,
  callValue: BN,
  functionToCall: utils.FunctionFragment
) {
  const executionManager = new ExecutionManager(code, callData, callValue);
  let execInfo = executionManager.currentStep;

  while (true) {
    await outputExecInfo(
      execInfo,
      code,
      callData,
      callValue,
      executionManager.opCodeList,
      functionToCall,
      10
    );

    const choices = [];
    if (execInfo.initialPC < code.length) {
      choices.push("Step Forwards");
    }
    if (execInfo.initialPC > 0) {
      choices.push("Step Backwards");
    }
    choices.push("Quit");

    const response = (await prompt({
      type: "select",
      name: "action",
      choices,
      message: "What do you want to do?",
    })) as { action: "Step Forwards" | "Step Backwards" | "Quit" };

    switch (response.action) {
      case "Step Forwards":
        execInfo = await executionManager.stepForwards();
        break;
      case "Step Backwards":
        execInfo = await executionManager.stepBackwards();
        break;
      case "Quit":
        process.exit(0);
    }
  }
}

async function outputExecInfo(
  execInfo: ExecutionInfo,
  code: Buffer,
  callData: Buffer,
  callValue: BN,
  opCodeList: OpcodeList,
  functionToCall: utils.FunctionFragment,
  height: number
) {
  const runStateOutput = await generateRunStateOutput(execInfo, height);

  const instructionTable = await generateInstructionTable(
    execInfo.initialPC,
    code,
    height,
    opCodeList
  );
  const masterTable = new Table();
  masterTable.push([instructionTable.toString(), runStateOutput.toString()]);

  const bytecodeOutput = generateBytecodeOutput(
    code,
    execInfo.initialPC,
    opCodeList
  );

  console.clear();
  console.log(chalk.bold("FUNCTION"));
  // NOTE: format('sighhash') actually returns the function
  console.log(
    `${functionToCall.format("sighash")}: 0x${chalk.bgRed(
      utils.Interface.getSighash(functionToCall).slice(2)
    )}`
  );
  console.log(chalk.bold("CALL DATA"));
  let callDataOutput = "0x";
  for (let i = 0; i < callData.length; i++) {
    if (i < 4) {
      callDataOutput = callDataOutput + chalk.bgRed(toPrettyByte(callData[i]));
    } else {
      callDataOutput = callDataOutput + toPrettyByte(callData[i]);
    }
  }
  console.log(callDataOutput);
  console.log(chalk.bold("CALL VALUE"));
  console.log(`0x${callValue.toString("hex")}`);

  console.log(bytecodeOutput);
  console.log(`${chalk.bold("Total Gas Used:")} ${execInfo.gasUsed}`);
  console.log(masterTable.toString());
}

async function generateStorageLine(
  lineCounter: number,
  storageDump: StorageDump
): Promise<string[]> {
  const storageItems = Object.keys(storageDump)
    .filter((key) => !storageDump[key].includes("deadbeaf"))
    .map((key) => [key, storageDump[key]]);

  if (lineCounter < storageItems.length) {
    return storageItems[lineCounter];
  } else {
    return ["", ""];
  }
}

function generateStackline(lineCounter: number, stack: Stack) {
  const line: string[] = [];
  const stackItems = _.clone(stack._store)
    .map((bn) => `0x${bn.toString("hex")}`)
    .reverse();
  if (lineCounter < stackItems.length) {
    line.push(stackItems[lineCounter]);
  } else {
    line.push("");
  }
  return line;
}

function generateMemoryLine(lineCounter: number, memory: Memory) {
  const line: string[] = [];

  // TODO: Just calculate the iterator and copy the value
  const memoryItems = _.clone(memory._store).reverse();

  if (lineCounter < memoryItems.length) {
    line.push(
      memoryItems[lineCounter] === 0
        ? ""
        : toPrettyHex(memoryItems[lineCounter])
    );
  } else {
    line.push("");
  }
  return line;
}

async function generateInstructionTable(
  currentCounter: number,
  code: Buffer,
  height: number,
  opCodeList: OpcodeList
): Promise<string> {
  const opCodeExecTable = new Table({
    head: ["PC", "OP CODE", "INSTRUCTION", "GAS COST"],
    colWidths: [10, 10, 20, 10],
  });

  const numberOfLines = Math.min(height, code.length - currentCounter);

  let printCounter = currentCounter;

  for (let i = 0; i < numberOfLines && printCounter < code.length; i++) {
    const opCodeInfo = opCodeList.get(code[printCounter]);
    const currentColor =
      printCounter === currentCounter ? chalk.bgBlue : chalk.white;
    const valueColor =
      printCounter === currentCounter ? chalk.bgMagenta : chalk.white;

    opCodeExecTable.push([
      currentColor(toPrettyHex(printCounter)),
      toPrettyHex(code[printCounter]),
      getInstructionName(
        opCodeList,
        printCounter,
        currentColor,
        valueColor,
        code
      ),
      opCodeInfo ? currentColor(toPrettyHex(opCodeInfo.fee)) : "",
    ]);

    printCounter = incrementCounter(printCounter, code, opCodeList);
  }
  return opCodeExecTable.toString();
}

function getInstructionName(
  opCodeList: OpcodeList,
  currentCounter: number,
  instructionColor: Chalk,
  valueColor: Chalk,
  code: Buffer
): string {
  const opCodeInfo = opCodeList.get(code[currentCounter]);
  // It looks like bin-runtime output can contain invalid opcodes as long as they're not executed
  if (!opCodeInfo) {
    return toPrettyHex(code[currentCounter]);
  }

  let instruction = `${instructionColor(opCodeInfo.fullName)}`;
  if (opCodeInfo.name === "PUSH") {
    const values = code.slice(
      currentCounter + 1,
      incrementCounter(currentCounter, code, opCodeList)
    );
    instruction += ` ${valueColor("0x" + values.toString("hex"))}`;
  }
  return instruction;
}
function generateBytecodeOutput(
  code: Buffer,
  currentCounter: number,
  opCodeList: OpcodeList
): string {
  let byteCodeOutput = "";
  const lineWidth = 100;
  const startIndex = Math.max(0, currentCounter - lineWidth * 1);
  const finishIndex = startIndex + lineWidth * 10;
  let printCounter = startIndex;

  while (printCounter < finishIndex && printCounter < code.length) {
    if (currentCounter === printCounter) {
      const opCode = opCodeList.get(code[printCounter])!;
      let numToPush = opCode.name === "PUSH" ? opCode.code - 0x5f : 0;

      byteCodeOutput += chalk.bgBlue(toPrettyByte(code[printCounter]));

      while (numToPush !== 0) {
        numToPush--;
        printCounter++;

        byteCodeOutput += chalk.bgMagenta(toPrettyByte(code[printCounter]));
      }
    } else {
      byteCodeOutput += toPrettyByte(code[printCounter]);
    }

    printCounter++;
  }
  if (finishIndex < code.length) {
    byteCodeOutput = byteCodeOutput + "...";
  }
  return `${chalk.bold("BYTECODE")}\n${byteCodeOutput}`;
}

async function generateRunStateOutput(
  info: ExecutionInfo,
  height: Number
): Promise<string> {
  const runStateTable = new Table({
    colWidths: [20, 20, 20, 20],
    head: ["STACK", "MEMORY", "STORAGE KEY", "STORAGE VALUE"],
  });

  for (let i = 0; i < height; i++) {
    runStateTable.push([
      ...generateStackline(i, info.stack),
      ...generateMemoryLine(i, info.memory),
      ...(await generateStorageLine(i, info.storageDump)),
    ]);
  }
  return runStateTable.toString();
}

function getOpcodeInfo(code: number, opCodeList: OpcodeList): Opcode {
  const opcodeInfo = opCodeList.get(code);
  if (!opcodeInfo) {
    throw new Error(`Invalid opcode ${toPrettyHex(code)}`);
  }
  return opcodeInfo;
}
